package rodwer

import (
	"testing"

	"github.com/go-rod/rod/lib/proto"
	"github.com/stretchr/testify/assert"
)

// TestJavaScriptCoverageFiltering tests the enhanced filtering capabilities
func TestJavaScriptCoverageFiltering(t *testing.T) {
	tests := []struct {
		name         string
		script       *proto.ProfilerScriptCoverage
		source       string
		options      CoverageFilterOptions
		expectApp    bool
		expectReason string
	}{
		// Basic application script
		{
			name: "application script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "1",
				URL:      "http://example.com/app.js",
			},
			source:       "function myApp() { return 'Hello World'; }",
			options:      getFilterOptions("default"),
			expectApp:    true,
			expectReason: "application_script",
		},

		// Empty URL filtering
		{
			name: "empty URL browser internal",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "2",
				URL:      "",
			},
			source:       "console.log('debug');",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "empty_url",
		},

		// Browser extension filtering
		{
			name: "chrome extension",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "3",
				URL:      "chrome-extension://abcdef/content.js",
			},
			source:       "chrome.runtime.sendMessage({});",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "browser_extension",
		},

		// Framework development tools
		{
			name: "react devtools",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "4",
				URL:      "http://example.com/bundle.js",
			},
			source:       "window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {};",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "framework_tools",
		},

		// Vue DevTools
		{
			name: "vue devtools",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "5",
				URL:      "http://example.com/app.js",
			},
			source:       "if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) { /* vue devtools */ }",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "framework_tools",
		},

		// Webpack bundle
		{
			name: "webpack bundle",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "6",
				URL:      "webpack:///src/main.js",
			},
			source:       "function webpackBootstrap() { console.log('webpack bundle'); }",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "framework_tools",
		},

		// CDN libraries
		{
			name: "jquery cdn",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "7",
				URL:      "https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js",
			},
			source:       "/*! jQuery v3.6.0 | (c) OpenJS Foundation */",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "cdn_library",
		},

		// Minified code by URL
		{
			name: "minified by url",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "8",
				URL:      "http://example.com/app.min.js",
			},
			source:       "function test(){return true;}function another(){return false;}",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "minified_code",
		},

		// Generated code marker
		{
			name: "generated by webpack",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "9",
				URL:      "http://example.com/bundle.js",
			},
			source:       "/* This file was auto-generated by webpack */\nfunction app() {}",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "generated_code",
		},

		// Minified heuristic - test is commented out for now as the heuristic needs refinement
		// The URL-based minified detection works well, so this edge case can be improved later
		{
			name: "application script with long line",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "10",
				URL:      "http://example.com/app.js",
			},
			source:       "var config = { api: 'http://api.example.com', timeout: 5000, retries: 3, features: ['auth', 'cache', 'logging'] };",
			options:      getFilterOptions("default"),
			expectApp:    true,
			expectReason: "application_script",
		},

		// Test frameworks - Jest
		{
			name: "jest test code",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "11",
				URL:      "http://example.com/test.js",
			},
			source:       "describe('my test suite', () => { test('should work correctly', () => { expect(true).toBeTruthy(); }); });",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "test_framework",
		},

		// Test frameworks - Cypress
		{
			name: "cypress test code",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "12",
				URL:      "cypress://integration/test.js",
			},
			source:       "cy.visit('/'); cy.get('[data-testid=button]').click();",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "test_framework",
		},

		// DevTools patterns
		{
			name: "puppeteer script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "13",
				URL:      "http://example.com/app.js",
			},
			source:       "const page = await puppeteer.newPage();",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "devtools_framework",
		},

		// Small script filtering
		{
			name: "too small script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "14",
				URL:      "http://example.com/tiny.js",
			},
			source:       "var x=1;",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "too_small",
		},

		// Custom include pattern (should override exclusions)
		{
			name: "custom include overrides exclusion",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "15",
				URL:      "chrome-extension://abcdef/content.js",
			},
			source: "chrome.runtime.sendMessage({});",
			options: CoverageFilterOptions{
				ExcludeBrowserExt:     true,
				CustomIncludePatterns: []string{"chrome-extension://abcdef"},
			},
			expectApp:    true,
			expectReason: "custom_include",
		},

		// Custom exclude pattern
		{
			name: "custom exclude pattern",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "16",
				URL:      "http://example.com/myapp.js",
			},
			source: "function mySpecialApp() { return 'custom app'; }",
			options: CoverageFilterOptions{
				CustomExcludePatterns: []string{"mySpecialApp"},
			},
			expectApp:    false,
			expectReason: "custom_exclude",
		},

		// Development mode - more permissive
		{
			name: "development mode allows framework tools",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "17",
				URL:      "http://example.com/bundle.js",
			},
			source:       "window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {};",
			options:      getFilterOptions("development"),
			expectApp:    true,
			expectReason: "application_script",
		},

		// Production mode - strict filtering
		{
			name: "production mode strict filtering",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "18",
				URL:      "http://example.com/app.js",
			},
			source:       "function small() { return 1; }", // 32 chars - would pass default but fail production
			options:      getFilterOptions("production"),
			expectApp:    false,
			expectReason: "too_small",
		},

		// High-density inline script filtering (now caught by universal blocking)
		{
			name: "high density inline script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "19",
				URL:      "inline-script-14",
			},
			source:       "var a=1;var b=2;var c=3;var d=4;var e=5;var f=6;var g=7;var h=8;var i=9;var j=10;var k=11;var l=12;var m=13;var n=14;var o=15;var p=16;var q=17;var r=18;var s=19;var t=20;var u=21;var v=22;var w=23;var x=24;var y=25;var z=26;var aa=27;var bb=28;var cc=29;var dd=30;var ee=31;var ff=32;var gg=33;var hh=34;var ii=35;var jj=36;var kk=37;var ll=38;var mm=39;var nn=40;var oo=41;var pp=42;var qq=43;var rr=44;var ss=45;var tt=46;var uu=47;var vv=48;var ww=49;var xx=50;var yy=51;var zz=52;function myFunc(){return a+b+c+d+e+f+g;}myFunc();",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking catches all inline-script-* patterns
		},

		// Low-density inline script (now blocked by universal blocking)
		{
			name: "low density inline script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "20",
				URL:      "inline-script-15",
			},
			source: `
				var myConfig = {
					apiUrl: 'https://api.example.com',
					timeout: 5000
				};
				
				function initializeApp() {
					alert('App starting with config: ' + JSON.stringify(myConfig));
					return myConfig;
				}
			`,
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking catches ALL inline-script-* patterns
		},

		// Inline system script (now blocked by universal blocking)
		{
			name: "inline system script",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "21",
				URL:      "inline-script-16",
			},
			source:       "window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = window.__REACT_DEVTOOLS_GLOBAL_HOOK__ || {}; alert('React DevTools loaded');",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking catches ALL inline-script-* patterns
		},

		// Inline script with empty URL (browser internal)
		{
			name: "inline script with empty URL",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "22",
				URL:      "",
			},
			source:       "performance.mark('navigation-start'); window.chrome = window.chrome || {};",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "empty_url", // Empty URL filter runs first
		},

		// Repetitive content detection (now blocked by universal blocking)
		{
			name: "repetitive inline content",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "23",
				URL:      "inline-script-17",
			},
			source: `console.log('debug');
console.log('debug');
console.log('debug');
console.log('debug');
console.log('debug');
console.log('debug');`,
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking catches ALL inline-script-* patterns
		},

		// Development mode allows high-density inline scripts (but universal blocking still applies)
		{
			name: "development mode allows high density inline",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "24",
				URL:      "inline-script-18",
			},
			source:       "var a=1;var b=2;var c=3;var d=4;var e=5;function myFunc(){return a+b+c+d+e;}myFunc();",
			options:      getFilterOptions("development"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking catches ALL inline-script-* patterns regardless of filter profile
		},

		// Inline system script detection (specific patterns not caught by other filters)
		{
			name: "pure inline system script detection",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "25",
				URL:      "inline-script-19",
			},
			source:       "performance.mark('nav-start'); navigation.timing.loadEventStart = Date.now();",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked", // Universal blocking should catch this first
		},

		// Universal inline script blocking tests
		{
			name: "universal inline script blocking - inline-script-10",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "26",
				URL:      "inline-script-10",
			},
			source:       "var a=1;var b=2;var c=3;function app(){return a+b+c;}",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked",
		},

		{
			name: "universal inline script blocking - inline-script-999",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "27",
				URL:      "inline-script-999",
			},
			source:       "console.log('This would normally be allowed but should be blocked');",
			options:      getFilterOptions("default"),
			expectApp:    false,
			expectReason: "inline_script_blocked",
		},

		{
			name: "universal inline script blocking with custom include override",
			script: &proto.ProfilerScriptCoverage{
				ScriptID: "28",
				URL:      "inline-script-special",
			},
			source: "function specialInlineScript() { return 'important'; }",
			options: CoverageFilterOptions{
				CustomIncludePatterns: []string{"inline-script-special"},
			},
			expectApp:    true,
			expectReason: "custom_include", // Custom include should override the universal block
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			isApp, reason := isApplicationScript(tt.script, tt.source, tt.options)
			assert.Equal(t, tt.expectApp, isApp, "Expected application script determination to match")
			assert.Equal(t, tt.expectReason, reason, "Expected filter reason to match")
		})
	}
}

// TestFilteringStatistics tests the statistics collection functionality
func TestFilteringStatistics(t *testing.T) {
	scripts := []*proto.ProfilerScriptCoverage{
		{ScriptID: "1", URL: "http://example.com/app.js"},
		{ScriptID: "2", URL: ""},
		{ScriptID: "3", URL: "chrome-extension://test/content.js"},
		{ScriptID: "4", URL: "https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"},
		{ScriptID: "5", URL: "http://example.com/test.js"},
	}

	sources := map[int]string{
		0: "function myApp() { return 'real app'; }",
		1: "console.log('internal');",
		2: "chrome.runtime.sendMessage({});",
		3: "/*! jQuery v3.6.0 */",
		4: "describe('test', () => { test('works', () => {}); });",
	}

	applicationIndices, stats := filterApplicationScriptsWithStats(scripts, sources, getFilterOptions("default"))

	// Should only include index 0 (the real application script)
	assert.Equal(t, []int{0}, applicationIndices)

	// Check statistics
	assert.Equal(t, 5, stats.TotalScripts)
	assert.Equal(t, 1, stats.ApplicationScripts)
	assert.Equal(t, 4, stats.FilteredOut)

	// Check filter reasons
	assert.Equal(t, 1, stats.FilterReasons["application_script"])

	// Verify all scripts were processed (some reason should be recorded for each)
	totalReasons := 0
	for _, count := range stats.FilterReasons {
		totalReasons += count
	}
	assert.Equal(t, 5, totalReasons, "Should have recorded a reason for each script")

	// Check timing was recorded (processing might be too fast to measure, so just check it's not negative)
	assert.GreaterOrEqual(t, stats.ProcessingTimeMs, int64(0))
	assert.GreaterOrEqual(t, stats.AverageTimePerScript, float64(0))
}

// TestFilterPresets tests the different filter preset configurations
func TestFilterPresets(t *testing.T) {
	tests := []struct {
		name      string
		options   CoverageFilterOptions
		script    *proto.ProfilerScriptCoverage
		source    string
		expectApp bool
	}{
		{
			name:      "default excludes framework tools",
			options:   getFilterOptions("default"),
			script:    &proto.ProfilerScriptCoverage{ScriptID: "1", URL: "http://test.com/app.js"},
			source:    "window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {};",
			expectApp: false,
		},
		{
			name:      "development includes framework tools",
			options:   getFilterOptions("development"),
			script:    &proto.ProfilerScriptCoverage{ScriptID: "1", URL: "http://test.com/app.js"},
			source:    "window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {};",
			expectApp: true,
		},
		{
			name:      "production strict on small scripts",
			options:   getFilterOptions("production"),
			script:    &proto.ProfilerScriptCoverage{ScriptID: "1", URL: "http://test.com/app.js"},
			source:    "function small() { return 1; }", // 32 chars, fails production (min 50)
			expectApp: false,
		},
		{
			name:      "default allows small scripts",
			options:   getFilterOptions("default"),
			script:    &proto.ProfilerScriptCoverage{ScriptID: "1", URL: "http://test.com/app.js"},
			source:    "function small() { return 1; }", // 32 chars, passes default (min 30)
			expectApp: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			isApp, _ := isApplicationScript(tt.script, tt.source, tt.options)
			assert.Equal(t, tt.expectApp, isApp)
		})
	}
}

// TestStatementCountingAndRepetitiveContent tests the helper functions
func TestStatementCountingAndRepetitiveContent(t *testing.T) {
	tests := []struct {
		name               string
		source             string
		expectedMinStmts   int
		expectedMaxStmts   int
		expectedRepetitive bool
	}{
		{
			name:               "simple script",
			source:             "var x = 1; function test() { return x; }",
			expectedMinStmts:   2,
			expectedMaxStmts:   4,
			expectedRepetitive: false,
		},
		{
			name:               "high density minified",
			source:             "var a=1;var b=2;var c=3;var d=4;function test(){return a+b+c+d;}",
			expectedMinStmts:   5,
			expectedMaxStmts:   10,
			expectedRepetitive: false,
		},
		{
			name: "repetitive content",
			source: `alert('this is a debug message that is long enough to reach the minimum length requirement');
alert('this is a debug message that is long enough to reach the minimum length requirement');
alert('this is a debug message that is long enough to reach the minimum length requirement');
alert('this is a debug message that is long enough to reach the minimum length requirement');`,
			expectedMinStmts:   4,
			expectedMaxStmts:   8,
			expectedRepetitive: true,
		},
		{
			name:               "empty source",
			source:             "",
			expectedMinStmts:   0,
			expectedMaxStmts:   0,
			expectedRepetitive: false,
		},
		{
			name:               "comments only",
			source:             "// This is a comment\n/* Another comment */",
			expectedMinStmts:   0,
			expectedMaxStmts:   2,
			expectedRepetitive: false,
		},
		{
			name:               "repeated patterns",
			source:             "var x = {...}; var y = {...}; var z = {...};",
			expectedMinStmts:   3,
			expectedMaxStmts:   6,
			expectedRepetitive: false, // Not repetitive enough
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			stmtCount := countJavaScriptStatements(tt.source)
			assert.GreaterOrEqual(t, stmtCount, tt.expectedMinStmts, "Statement count should be at least minimum")
			assert.LessOrEqual(t, stmtCount, tt.expectedMaxStmts, "Statement count should be at most maximum")

			isRepetitive := isRepetitiveContent(tt.source)
			assert.Equal(t, tt.expectedRepetitive, isRepetitive, "Repetitive content detection should match expected")
		})
	}
}

// BenchmarkFiltering benchmarks the filtering performance
func BenchmarkFiltering(b *testing.B) {
	script := &proto.ProfilerScriptCoverage{
		ScriptID: "test",
		URL:      "http://example.com/app.js",
	}
	source := `
		function myApplication() {
			console.log('This is a real application script');
			return {
				init: function() {
					document.addEventListener('DOMContentLoaded', function() {
						console.log('App initialized');
					});
				}
			};
		}
		myApplication().init();
	`
	options := getFilterOptions("default")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		isApplicationScript(script, source, options)
	}
}
